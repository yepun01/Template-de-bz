--[[

â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘
 â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•   â•šâ•â•

        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
       â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
       â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•

     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•
     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ•”â•
     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•‘
      â•šâ•â•â•â•â•â•    â•šâ•â•   â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•      â•šâ•â•


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ª ğ‚ğ¨ğ§ğ­ğğ±ğ­ğ€ğœğ­ğ¢ğ¨ğ§ğ”ğ­ğ¢ğ¥ğ¢ğ­ğ² ğ€ğğˆ
	â–ª Properties
		â–ª bool Archivable
		â–ª string ClassName
		â–ª string Name
		â–ª Instance Parent
	â–ª Functions
		â–ª BindAction(string actionName, Function functionToBind, bool createTouchButton, Tuple inputTypes)
		â–ª BindActionAtPriority(string actionName, Function functionToBind, bool createTouchButton, int priorityLevel, Tuple inputTypes)
		â–ª UnbindAction(String actionName)
		â–ª DisableAction(string actionName)
			â–ª Disables action and disconnects events. Works the same as UnbindAction but the button stays.
			â–ª DisableAction is a bit wonky right now.
		â–ª SetTitle(string actionName, string title)
		â–ª SetImage(string actionName, string image)
		â–ª SetPressedColor(string actionName, Color3 color)
			â–ª Sets the pressed color of the button.
		â–ª SetReleasedColor(string actionName, Color3 color)
			â–ª Sets the released color of the button.
		â–ª GetButton(string actionName)
		â–ª MakeButtonRound(actionName, amount)
			â–ª Changes the shape and interaction area of the button.
		â–ª MakeButtonSquare(actionName)
			â–ª Changes the shape and interaction area of the button.
	â–ª Events
		â–ª LocalToolEquipped(Instance toolEquipped)
		â–ª LocalToolUnequipped(Instance toolUnequipped)


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ª ğˆğ§ğŸğ¨ğ«ğ¦ğšğ­ğ¢ğ¨ğ§

	â–ª Written by PseudoPerson
		â–ª https://www.roblox.com/users/1735621911/profile
	â–ª CC BY License (https://creativecommons.org/licenses/by/4.0)
		â–ª Summary: Do what ever you want with the module as long as credit is in the code :)
	â–ª Developer Forum Post: https://devforum.roblox.com/t/easy-mobile-buttons-contextactionutility/804219
	â–ª Cancel UserInputState may not always fire. This is untested.


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ª ğ•ğğ«ğ¬ğ¢ğ¨ğ§

	â–ª v.0.20.10.3


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ª ğ‘ğğ¬ğ¨ğ®ğ«ğœğğ¬

	â–ª Buttons
		â–ª Default Button:   rbxassetid://5713982324
		â–ª Read Button:      rbxassetid://5743592925
		â–ª Attack Button:    rbxassetid://5743593320
		â–ª Target Button:    rbxassetid://5743593654
		â–ª Hamburger Button: rbxassetid://5743594013
		â–ª ! Button:         rbxassetid://5754149564
		â–ª ? Button:         rbxassetid://5754150372
		â–ª ... Button:       rbxassetid://5754151192
		â–ª - Button:         rbxassetid://5754152113
		â–ª + Button:         rbxassetid://5754152510
		â–ª Cancel Button:    rbxassetid://5754151652
		â–ª Speech Button:    rbxassetid://5754152998
		â–ª Star Button:      rbxassetid://5754153324
		â–ª Sword Button:     rbxassetid://5754154247
		â–ª Sun Button:       rbxassetid://5754154839
	â–ª Developer Forum Post With Vector Images
		â–ª https://devforum.roblox.com/t/easy-mobile-buttons-contextactionutility/804219


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

]]

--// ğŒğ¨ğğ®ğ¥ğ ğ“ğšğ›ğ¥ğ //--
local ContextActionUtility = {}

--// ğ’ğğ«ğ¯ğ¢ğœğğ¬ //--
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

local Players = game:GetService("Players")

--// ğ•ğšğ«ğ¢ğšğ›ğ¥ğğ¬ //--
	--player
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")
local TouchGui
local TouchControlFrame
local JumpButton

	--mobile
local isMobile = UserInputService.TouchEnabled
if isMobile then
	TouchGui = PlayerGui:WaitForChild("TouchGui")
	TouchControlFrame = TouchGui:WaitForChild("TouchControlFrame")
	JumpButton = TouchControlFrame:WaitForChild("JumpButton")
end

	--{actionName = {Name, Button, Slot, Connections}}
local Buttons = {}


--âš« This can be changed. The indexes are the fill priority (1 being the highest priority).
--1.1x
local ButtonPositions = {
	[1] = UDim2.new(-0.4169, 0, 0.715, 0);
	[2] = UDim2.new(-0.165, 0, -0.165, 0);
	[3] = UDim2.new(0.715, 0, -0.4169, 0);
	[4] = UDim2.new(-1.1077, 0, -0.0396, 0);
	[5] = UDim2.new(-0.858, 0, -0.858, 0);
	[6] = UDim2.new(-0.0396, 0, -1.1077, 0);
}

--// ğ…ğ®ğ§ğœğ­ğ¢ğ¨ğ§ğ¬ //--
local function GetNextSlot()
	local takenSlots = {}
	--Loop makes a table with button slot numbers as indexes
	for actionName, buttonData in pairs(Buttons) do
		takenSlots[buttonData.Slot] = true
	end
	--Loop looks for first open slot
	for i = 1, #ButtonPositions do
		if not takenSlots[i] then
			--Returns first open slot
			return i
		end
	end
	--If no open slot is found function returns nil
	return nil
end

local function ConnectButton(actionName, functionToBind)
	local data = Buttons[actionName]
	local button = data.Button
	local connections = data.Connections or {}

	local function inputBeganHandler(inputObject)

		--Feeds correct input into the function
		functionToBind(actionName, Enum.UserInputState.Begin, inputObject)
		button.ImageColor3 = button.BorderColor3
		local title = button:FindFirstChild("title")
		if title then
			title.TextColor3 = button.BorderColor3
		end
	end
	connections.Begin = button.InputBegan:Connect(inputBeganHandler)

	local function inputChangedHandler(inputObject)
		--Feeds correct input into the function
		functionToBind(actionName, Enum.UserInputState.Change, inputObject)
	end
	connections.Changed = button.InputChanged:Connect(inputChangedHandler)

	local function inputEndedHandler(inputObject)
		--Feeds correct input into the function
		functionToBind(actionName, Enum.UserInputState.End, inputObject)
		button.ImageColor3 = button.BackgroundColor3
		local title = button:FindFirstChild("title")
		if title then
			title.TextColor3 = button.BackgroundColor3
		end
	end
	connections.MenuOpened = GuiService.MenuOpened:Connect(inputEndedHandler)
	connections.End = button.InputEnded:Connect(inputEndedHandler)

	--Roblox touch support is wonky. This makes it so it (probably) always looks right.
	local function mouseLeaveHandler()
		button.ImageColor3 = button.BackgroundColor3
		local title = button:FindFirstChild("title")
		if title then
			title.TextColor3 = button.BackgroundColor3
		end
	end
	button.MouseLeave:Connect(mouseLeaveHandler)
end

local function DisconnectButton(actionName)
	local data = Buttons[actionName]
	if not data.Connections then return end
	for i, p in pairs(data.Connections) do
		if p then
			p:Disconnect()
		end
	end
	--Will do some testing to see if this is needed Â¯\_(ãƒ„)_/Â¯
	data.Connections = {}
end

local function newDefaultButton(actionName, slot)
	local newButton
	newButton = Instance.new("ImageButton")
	newButton.Name = actionName.."Button"
	newButton.BackgroundTransparency = 1
	newButton.Size = UDim2.new(0.8, 0, 0.8, 0)
	newButton.Image = "rbxassetid://5713982324"
	newButton.ImageTransparency = 0.5
	newButton.AnchorPoint = Vector2.new(0.5, 0.5)
	--Used for unactived color
	newButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	--Used for activated color
	newButton.BorderColor3 = Color3.fromRGB(125, 125, 125)

	--Without this the jump button locks in the jump state because the input ends incorrectly. Dont let the button hitboxes overlap the jump button hit box.
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0.5, 0)
	corner.Parent = newButton

	newButton.Position = ButtonPositions[slot]
	return newButton
end

local function BindButton(actionName, functionToBind)
	local button
	local slot
	local data = Buttons[actionName]
	if data then
		print("is Data")
		if data.Connections then
			print("is Connections")
			DisconnectButton(actionName)
		end
		if data.Slot then
			print("is Slot")
			slot = data.Slot
		else
			slot = GetNextSlot()
		end
		if data.Button then
			print("is Button")
			button = data.Button
			--Will do some testing to see if this is needed Â¯\_(ãƒ„)_/Â¯
			button.ImageColor3 = button.BackgroundColor3
			local title = button:FindFirstChild("title")
			if title then
				title.TextColor3 = button.BackgroundColor3
			end
		else
			button = newDefaultButton(actionName, slot)
		end

	else
		slot = GetNextSlot()
		button = newDefaultButton(actionName, slot)
	end

	button.Parent = JumpButton

	Buttons[actionName] = {["Name"] = actionName, ["Button"] = button, ["Slot"] = slot, ["Connections"] = {}}
	--Should I use OOP? Probably. Am I using Lua's weird table based OOP? No.
	ConnectButton(actionName, functionToBind)
end

local function UnbindButton(actionName)
	--Gets button data
	local data = Buttons[actionName]
	if not data then return end
	--Disconnects connections
	DisconnectButton(actionName)
	if data.Button then
		data.Button:Destroy()
	end
	--Need to test if this line will do everything. I believe this leaks or something b|c it's just parenting the data to nil.
	Buttons[actionName] = nil
end

local function DisableButton(actionName)
	local data = Buttons[actionName]
	DisconnectButton(actionName)

	local button = data.Button
	button.ImageColor3 = button.BackgroundColor3
	local title = button:FindFirstChild("title")
	if title then
		title.TextColor3 = button.BackgroundColor3
	end
end

	--Default jump button can get stuck in the down position. Using a newish ui thing to fix this
local function FixDefaultJumpButton()
	--Removes the corners of the button interaction hitbox so button cant lock
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0.5, 0)
	uiCorner.Parent = JumpButton
end
FixDefaultJumpButton() --Little unorganized to call this here but Â¯\_(ãƒ„)_/Â¯

--// ğŒğ¨ğğ®ğ¥ğ ğ•ğšğ«ğ¢ğšğ›ğ¥ğğ¬ //--
	--Properties
ContextActionUtility.Archivable = ContextActionService.Archivable
ContextActionUtility.ClassName = ContextActionService.ClassName
ContextActionUtility.Name = ContextActionService.Name
ContextActionUtility.Parent = ContextActionService.Parent

	--Events
ContextActionUtility.LocalToolEquipped = ContextActionService.LocalToolEquipped
ContextActionUtility.LocalToolUnequipped = ContextActionService.LocalToolUnequipped

--// ğŒğ¨ğğ®ğ¥ğ ğ…ğ®ğ§ğœğ­ğ¢ğ¨ğ§ğ¬ //--
function ContextActionUtility:BindAction(actionName, functionToBind, createTouchButton, ...)
	ContextActionService:BindAction(actionName, functionToBind, false, ...)
	if createTouchButton and isMobile then
		BindButton(actionName, functionToBind)
	end
end

function ContextActionUtility:BindActionAtPriority(actionName, functionToBind, createTouchButton, priorityLevel, ...)
	ContextActionService:BindAction(actionName, functionToBind, false, priorityLevel, ...)
	if createTouchButton and isMobile then
		BindButton(actionName, functionToBind)
	end
end

function ContextActionUtility:UnbindAction(actionName)
	ContextActionService:UnbindAction(actionName)
	if isMobile then
		UnbindButton(actionName)
	end
end

	--Added functionality: Disconnects events but the button stays. Effects that can be chosen: Shrink alpha, Fade alpha, Darken alpha
function ContextActionUtility:DisableAction(actionName, effectList)
	ContextActionService:UnbindAction(actionName)
	if isMobile then
		DisableButton(actionName, effectList)
	end
end

function ContextActionUtility:SetTitle(actionName, title)
	local data = Buttons[actionName]
	if not data then return end
	if not title then
		title = actionName
	end
	local button = data.Button
	if not button then return end
	local textLabel = button:FindFirstChild("title")
	if not textLabel then
		textLabel = Instance.new("TextLabel")
		textLabel.Name = "title"
		textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.Size = UDim2.new(0.75, 0, 0.45, 0)
		textLabel.Font = Enum.Font.SourceSansBold
		textLabel.TextScaled = true
		textLabel.TextTransparency = 0.5
		textLabel.TextColor3 = Color3.new(255, 255, 255)
		textLabel.TextXAlignment = Enum.TextXAlignment.Center
		textLabel.TextYAlignment = Enum.TextYAlignment.Center
	end
	textLabel.Visible = true
	textLabel.Text = title
	textLabel.Parent = button
end

function ContextActionUtility:SetImage(actionName, image)
	local data = Buttons[actionName]
	if not data then return end
	data.Button.Image = image
end

	--Added functionality: Color of pressed button.
function ContextActionUtility:SetPressedColor(actionName, color)
	local data = Buttons[actionName]
	if not data then return end
	local button = data.Button
	if not button then return end
	print("Setting Pressed Color")
	button.BorderColor3 = color
end

	--Added functionality: Color of released button
function ContextActionUtility:SetReleasedColor(actionName, color)
	local data = Buttons[actionName]
	if not data then return end
	local button = data.Button
	if not button then return end
	button.ImageColor3 = color
	button.BackgroundColor3 = color
	local title = button:FindFirstChild("title")
	if title then
		title.TextColor3 = color
	end
end

	--Added functionality: Shape of button and interaction box
function ContextActionUtility:MakeButtonSquare(actionName)
	local data = Buttons[actionName]
	if not data then return end
	local button = data.Button
	if not button then return end

	local corner = button:FindFirstChildOfClass("UICorner")
	if corner then
		corner.CornerRadius = UDim.new(0, 0)
	end
end

	--Added functionality: Shape of button and interaction box
function ContextActionUtility:MakeButtonRound(actionName, amount)
	local data = Buttons[actionName]
	if not data then return end
	local button = data.Button
	if not button then return end

	local corner = button:FindFirstChildOfClass("UICorner")
	if not corner then
		local corner = Instance.new("UICorner", button)
	end
	if not amount then
		amount = 0.5
	end
	corner.CornerRadius = UDim.new(amount, 0)
end


function ContextActionUtility:GetButton(actionName)
	local data = Buttons[actionName]
	if not data then return nil end
	return data.Button
end

return ContextActionUtility